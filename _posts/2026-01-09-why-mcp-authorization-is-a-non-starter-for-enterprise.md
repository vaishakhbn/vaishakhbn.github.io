---
layout: post
title: "Why MCP Authorization is a Non-Starter for Enterprises"
nav: blog
canonical_url: https://medium.com/@vbnarasi/why-mcp-authorization-is-a-non-starter-for-enterprise-230005e8ffdc
---

<p><em>Originally published on Medium: <a href="https://medium.com/@vbnarasi/why-mcp-authorization-is-a-non-starter-for-enterprise-230005e8ffdc">Why MCP Authorization is a Non-Starter for Enterprises</a></em></p>

<p><em>Part 2 of “Securing the Future of AI Agents: AuthN &amp; AuthZ in the Model Context Protocol”. Read </em><a href="/blog/establishing-the-case-for-mcp-security/"><em>Part 1 here</em></a></p><p>The MCP specification talks about adopting Oauth 2.1, mainly the features of Dynamic client registration, authorization code flows, token introspection. These are technically sophisticated OAuth patterns but not enough in my opinion. The paradigm works well for Public SaaS APIs and user driven authorization, but does not address that issues that will arise when enterprises deploy autonomous agents at scale. Let’s examine why this approach falls short.</p><h3>The Official MCP Auth Approach</h3><p>Let’s start by understanding what the MCP spec proposes. The authentication framework is built on three pillars:</p><h4>1. Dynamic Client Registration (DCR)</h4><pre>POST /register HTTP/1.1<br>Host: mcp-server.example.com<br>Content-Type: application/json</pre><pre>{<br>  &quot;client_name&quot;: &quot;My AI Assistant&quot;,<br>  &quot;redirect_uris&quot;: [&quot;http://localhost:8080/callback&quot;],<br>  &quot;grant_types&quot;: [&quot;authorization_code&quot;, &quot;refresh_token&quot;],<br>  &quot;token_endpoint_auth_method&quot;: &quot;client_secret_post&quot;<br>}</pre><p>Any MCP client can register itself dynamically with any MCP server. The server responds with client credentials, and this registers the AI agent.</p><h4>2. OAuth 2.1 Authorization Code Flow</h4><p>Once registered, the AI agent initiates a standard OAuth flow:</p><ol><li>Redirect user to authorization endpoint</li><li>User logs in and grants permissions</li><li>Receive authorization code</li><li>Exchange code for access token</li><li>Use token to call MCP tools</li></ol><h4>3. Resource and Audience Parameters</h4><p>The spec introduces concepts like resource indicators and audience parameters to scope access:</p><pre>GET /authorize?<br>  client_id=abc123&amp;<br>  resource=https://database.example.com&amp;<br>  audience=production-db&amp;<br>  scope=read:customers write:orders</pre><p>These look great, but I will highlight the problems from my perspective.</p><h3>Problem 1: Anonymous DCR is not ideal</h3><p>Dynamic Client Registration without pre-established trust is not something that is going to fly in enterprises. The problems of DCR are:</p><h4>The Registration Attack Surface</h4><p>Consider what happens when any client can register:</p><pre># Attacker registers a malicious client<br>malicious_client = register_client(<br>    name=&quot;Totally Legitimate AI Assistant&quot;,<br>    redirect_uri=&quot;https://attacker.com/steal-tokens&quot;<br>)</pre><pre># Now they have valid credentials<br>access_token = get_token(malicious_client)</pre><pre># And can discover all available tools<br>tools = mcp_server.list_tools(access_token)</pre><p>I must note that the spec suggests servers can implement “registration policies,” but provides no guidance on what these should be.</p><h4>The Compliance Problem</h4><p>Enterprise security teams have specific requirements:</p><ul><li><strong>Pre-approved client allowlists</strong>: Every client must be vetted before registration</li><li><strong>Cryptographic client identity</strong>: Not just a client_id string, but verified certificates</li><li><strong>Audit trail from day one</strong>: Who registered this client? When? Why?</li></ul><p>DCR does not provide these details and this will cause big problems when you go for complicance audits.</p><h3>Problem 2: OAuth Flows Don’t Match Agent Patterns</h3><p>OAuth was designed for human users authorizing applications to access their resources. AI agents do not fit very well into this paradigm. Here’s why</p><p>Enterprise AI agents will often run for hours or days:</p><pre>class DataAnalysisAgent:<br>    def run_quarterly_analysis(self):<br>        # This runs for 6 hours<br>        for customer_segment in segments:<br>            data = mcp_tool.query_database(segment)<br>            report = mcp_tool.generate_report(data)<br>            mcp_tool.save_to_s3(report)</pre><pre>        # OAuth token expired 5 hours ago<br>        # Refresh token might be revoked<br>        # No way to re-authorize without human</pre><p>OAuth’s token lifecycle might not align with agentic workflows:</p><ul><li>Access tokens expire (typically 1 hour)</li><li>Refresh tokens need to be stored securely</li></ul><h4>The Delegation Problem</h4><p>AI agents often act on behalf of users who aren’t present:</p><pre># Monday: Manager schedules agent task<br>manager.schedule_agent_task(<br>    agent=&quot;financial-reporter&quot;,<br>    task=&quot;Generate monthly P&amp;L&quot;,<br>    run_at=&quot;Friday 2am&quot;<br>)</pre><pre># Friday 2am: Agent needs manager&#39;s authorization<br># Problem: Manager is asleep</pre><p>OAuth does not work very well for delegated authorization where the authorizing user is absent when the agent runs.</p><h3>Problem 3: Missing Context Enrichment</h3><p>Enterprise authorization decisions require rich context that OAuth tokens do not provide.</p><h4>What OAuth Gives You</h4><pre>{<br>  &quot;sub&quot;: &quot;user-123&quot;,<br>  &quot;client_id&quot;: &quot;ai-agent-456&quot;,<br>  &quot;scope&quot;: &quot;read:database write:reports&quot;,<br>  &quot;exp&quot;: 1699564800<br>}</pre><h4>What Enterprises Actually Need</h4><pre>{<br>  &quot;sub&quot;: &quot;user-123&quot;,<br>  &quot;client_id&quot;: &quot;ai-agent-456&quot;,<br>  &quot;scope&quot;: &quot;read:database write:reports&quot;,<br>  &quot;context&quot;: {<br>    &quot;user_department&quot;: &quot;finance&quot;,<br>    &quot;user_role&quot;: &quot;analyst&quot;,<br>    &quot;user_clearance&quot;: &quot;confidential&quot;,<br>    &quot;agent_purpose&quot;: &quot;quarterly_reporting&quot;,<br>    &quot;data_classification&quot;: &quot;internal&quot;,<br>    &quot;compliance_frameworks&quot;: [&quot;SOC2&quot;, &quot;GDPR&quot;],<br>    &quot;session_id&quot;: &quot;sess-789abc&quot;,<br>    &quot;originating_request&quot;: &quot;req-def456&quot;,<br>    &quot;approval_chain&quot;: [<br>      {&quot;approver&quot;: &quot;manager-001&quot;, &quot;timestamp&quot;: &quot;2024-01-15T10:00:00Z&quot;},<br>      {&quot;approver&quot;: &quot;security-002&quot;, &quot;timestamp&quot;: &quot;2024-01-15T10:30:00Z&quot;}<br>    ],<br>    &quot;environment&quot;: &quot;production&quot;,<br>    &quot;risk_score&quot;: 0.3<br>  }<br>}</pre><p>This context is essential for real authorization decisions:</p><ul><li>Can this finance analyst’s agent access HR data? (No)</li><li>Can this agent run queries that scan &gt;1M records? (Depends on risk score)</li><li>Is this agent allowed to operate outside business hours? (Check approval chain)</li></ul><p>OAuth was never designed to carry this context, and adding these to token claims will bloat the tokens and will hit size limits.</p><h3>Problem 4: Token Management at Scale</h3><p>Enterprises don’t run one AI agent. They will run thousands. The MCP OAuth approach creates a token management nightmare.</p><h4>Token Storage and Security</h4><p>Where do these tokens live?</p><ul><li>In agent memory? (Lost on restart)</li><li>In a database? (Now you need encryption at rest)</li><li>In a token vault? (Additional infrastructure)</li><li>In Kubernetes secrets? (Size limitations)</li></ul><p>Each of these options has tradeoffs.</p><h4>Token Revocation Challenges</h4><p>When an employee leaves or changes roles:</p><pre># Need to revoke all tokens for this user across:<br>- All agents they&#39;ve authorized<br>- All tools they&#39;ve accessed<br>- All environments they&#39;ve touched<br>- All delegation chains they&#39;re part of</pre><pre># With OAuth, this means:<br>for token in find_all_tokens(user):<br>    revoke_token(token)  # Hope the agent checks revocation<br>    notify_agent(token)   # Hope the agent listens<br>    audit_log(token)      # For compliance</pre><pre># Meanwhile, agents are still running with cached tokens</pre><h3>Real Enterprise Requirements</h3><p>Here’s what enterprises actually need:</p><h4>1. Identity-First Architecture</h4><pre># Every request must have traceable identity<br>request:<br>  agent_identity:<br>    spiffe_id: &quot;spiffe://company.com/agent/analytics-prod&quot;<br>    attestation: &quot;signed-hardware-attestation&quot; #https://spiffe.io/docs/latest/spire-about/spire-concepts/#node-attestation<br>  user_context:<br>    principal: &quot;user@company.com&quot;<br>    groups: [&quot;finance&quot;, &quot;analysts&quot;]<br>    session: &quot;corp-sso-session-123&quot;<br>  purpose:<br>    task_id: &quot;quarterly-report-q4&quot;<br>    approved_by: [&quot;manager@company.com&quot;]</pre><h4>2. Policy-Based Authorization</h4><pre># OPA/Rego policy for context-aware decisions<br>allow {<br>    input.action == &quot;query_database&quot;<br>    input.agent.type == &quot;analytics&quot;<br>    input.user.department == input.resource.owner_department<br>    input.time.hour &gt;= 9<br>    input.time.hour &lt;= 17<br>    input.risk_score &lt; 0.5<br>}</pre><h4>3. Cryptographic Tool Verification</h4><pre>{<br>  &quot;tool&quot;: &quot;deploy_to_production&quot;,<br>  &quot;signature&quot;: &quot;sha256:xyz789...&quot;,<br>  &quot;signer&quot;: &quot;platform-team@company.com&quot;,<br>  &quot;metadata&quot;: {<br>    &quot;version&quot;: &quot;2.1.0&quot;,<br>    &quot;risk_level&quot;: &quot;high&quot;,<br>    &quot;requires_approval&quot;: true<br>  }<br>}</pre><h4>4. Complete Audit Trail</h4><pre>{<br>  &quot;timestamp&quot;: &quot;2024-01-20T10:30:00Z&quot;,<br>  &quot;agent&quot;: &quot;spiffe://company.com/agent/deploy-bot&quot;,<br>  &quot;user&quot;: &quot;devops@company.com&quot;,<br>  &quot;tool&quot;: &quot;deploy_to_production&quot;,<br>  &quot;parameters&quot;: {&quot;service&quot;: &quot;api&quot;, &quot;version&quot;: &quot;2.3.4&quot;},<br>  &quot;decision&quot;: &quot;allow&quot;,<br>  &quot;policy_version&quot;: &quot;1.2.3&quot;,<br>  &quot;justification&quot;: &quot;Scheduled deployment window, approved by release manager&quot;<br>}</pre><h3>The Path Forward</h3><p>The MCP spec does not address the requirements of enterprises deploying autonomous agents in production. Enterprises need</p><ul><li>Usage policies, not scopes</li><li>Delegation without interaction</li><li>Rich context for every decision made</li><li>Immutable audit trails</li></ul><p>In <a href="/blog/building-identity-first-authorization-for-mcp/">Part 3</a>, we will try to build this system using existing technologies. A combination of SPIFFE for identity, OPA for policy, and MCP gateways for enforcement to create an authorization system will work for enterprise AI agents.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=230005e8ffdc" width="1" height="1" alt="">
