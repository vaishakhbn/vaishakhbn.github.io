---
layout: post
title: "What Enterprise-Grade Authorization for MCP Should Look Like"
nav: blog
canonical_url: https://medium.com/@vbnarasi/building-identity-first-authorization-for-mcp-227c4c0c92f8
---

<p><em>Originally published on Medium: <a href="https://medium.com/@vbnarasi/building-identity-first-authorization-for-mcp-227c4c0c92f8">What Enterprise-Grade Authorization for MCP Should Look Like</a></em></p>

<p><em>Part 3 in the series “Securing the Future of AI Agents: AuthN &amp; AuthZ in the Model Context Protocol”</em></p><p><a href="/blog/why-mcp-authorization-is-a-non-starter-for-enterprise/">Part 2</a> focused on why the OAuth model doesn’t line up well with how enterprises think about access management in the Agentic world. In this post, I’m going to lay out the set of capabilities I believe are necessary if you want to run autonomous agents safely inside an enterprise: strong workload identity, policy-driven decisions, tight tool validation, and end-to-end observability.</p><h4>1. Identity-First</h4><p>Every entity: human, agent, or service should have a cryptographically verifiable identity established before any interaction begins.</p><h4>2. Policy-Based Authorization</h4><p>Authorization decisions should be made by evaluating policies, not checking scopes or ACLs.</p><h4>3. Zero Trust Architecture</h4><p>Everything should be verified explicitly, enforcing least privilege.</p><h4>4. Tool Validation</h4><p>Every MCP tool should have a cryptographic signature. Agents should verify not just that a tool exists, but that it is what it claims to be and comes from a trusted source.</p><h4>5. Complete Observability</h4><p>Every request, decision, and action should be logged with complete context. This is important for compliance.</p><h3>The Technical Stack</h3><p>To achieve the above capabilities, we can start by building with existing technologies. Here’s what we’re building with:</p><pre>identity_layer:<br>  humans: &quot;Corporate SSO with SAML/OIDC&quot;<br>  agents: &quot;SPIFFE/SPIRE&quot;<br>  services: &quot;Mutual TLS with certificate management&quot;<br>authorization_layer:<br>  engine: &quot;Open Policy Agent (OPA)&quot;<br>gateway_layer:<br>  proxy: &quot;NGINX or a custom MCP gateway&quot;<br>observability_layer:<br>  tracing: &quot;Open Telemetry&quot;<br>  logging: &quot;Structured logs with correlation IDs&quot;<br></pre><p>Let’s see how these pieces fit together.</p><h3>The Architecture</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Hk54toS5qUPZElDlNr4NFw.png" /></figure><h3>Identity Layer: SPIFFE/SPIRE</h3><p>SPIFFE (Secure Production Identity Framework For Everyone) provides cryptographically verifiable identities for workloads. Unlike OAuth’s client_id strings, SPIFFE identities are backed by short-lived X.509 certificates. In this model, SPIFFE doesn’t remove the user. User identity still comes from SSO. SPIFFE tells us which workload is speaking; SSO tells us who it’s acting on behalf of.</p><h3>Authorization Layer: Open Policy Agent</h3><p>OPA evaluates authorization policies written in Rego. Unlike OAuth scopes, Rego policies can express complex, context-aware rules. I have given 2 examples here. One for a basic policy structure. Another for a more complicated use-case. The beauty of using a Policy engine is that it can be managed as code and updated on the go at runtime.</p><h3>Basic Policy Structure</h3><pre>package mcp.authz<br>import future.keywords.contains<br>import future.keywords.if<br># Default deny<br>default allow := false<br># Allow analytics agents to read databases<br>allow if {<br>    input.agent.type == &quot;analytics&quot;<br>    input.action == &quot;query_database&quot;<br>    input.resource.classification in [&quot;public&quot;, &quot;internal&quot;]<br>    valid_time_window<br>    within_rate_limit<br>}<br># Helper: Check if within business hours<br>valid_time_window if {<br>    hour := time.clock(time.now_ns())[0]<br>    hour &gt;= 9<br>    hour &lt;= 17<br>    day := time.weekday(time.now_ns())<br>    day != &quot;Saturday&quot;<br>    day != &quot;Sunday&quot;<br>}<br># Helper: Check rate limits<br>within_rate_limit if {<br>    key := sprintf(&quot;%s:%s&quot;, [input.agent.id, input.action])<br>    rate := data.rate_limits[key]<br>    rate.count &lt; rate.limit<br>}</pre><h3>A more complex policy</h3><pre># Sophisticated policy considering multiple factors<br>allow if {<br>    # Identity verification<br>    input.agent.spiffe_id == sprintf(&quot;spiffe://company.com/ai-agents/%s/%s&quot;,<br>        [input.agent.environment, input.agent.name])<br># User context validation<br>    input.user.authenticated == true<br>    input.user.department == input.resource.owner_department<br>    # Risk assessment<br>    risk_score := calculate_risk_score<br>    risk_score &lt; 0.5<br>    # Compliance requirements<br>    required_frameworks := data.resources[input.resource.id].compliance<br>    satisfied_frameworks := {f |<br>        f := required_frameworks[_]<br>        check_compliance(f, input)<br>    }<br>    count(satisfied_frameworks) == count(required_frameworks)<br>    # Create audit record<br>    print(json.marshal({<br>        &quot;decision&quot;: &quot;allow&quot;,<br>        &quot;agent&quot;: input.agent.id,<br>        &quot;user&quot;: input.user.id,<br>        &quot;resource&quot;: input.resource.id,<br>        &quot;risk_score&quot;: risk_score,<br>        &quot;timestamp&quot;: time.now_ns()<br>    }))<br>}<br># Calculate risk score based on multiple factors<br>calculate_risk_score := score if {<br>    factors := [<br>        {&quot;weight&quot;: 0.3, &quot;value&quot;: agent_trust_score},<br>        {&quot;weight&quot;: 0.2, &quot;value&quot;: user_trust_score},<br>        {&quot;weight&quot;: 0.2, &quot;value&quot;: resource_sensitivity},<br>        {&quot;weight&quot;: 0.15, &quot;value&quot;: time_anomaly_score},<br>        {&quot;weight&quot;: 0.15, &quot;value&quot;: behavior_anomaly_score}<br>    ]<br>    score := sum([f.weight * f.value | f := factors[_]])<br>}</pre><h3>Gateway Architecture</h3><p>The MCP Gateway sits between AI agents and MCP servers, acting as a security enforcement point.</p><h3>Request Flow</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*ARqvJVRXyY1VFLQ7f1iRrQ.png" /></figure><h3>The Complete Picture</h3><p>This architecture delivers what enterprises need for the MCP protocol</p><ol><li>Every request has verified identity (SPIFEE/SPIRE+SSO)</li><li>Authorization is policy-driven and contextual(OPA)</li><li>Tools are cryptographically verified (Unified registry + signatures)</li><li>Complete audit trail</li><li>Defense against Tool poisoning and agent impersonation attacks</li><li>Unified security model that works accross the enterprise (One gateway, consistent policies, single audit stream)</li></ol><p>The takeaway here is simple. Treat AI agents like workloads with a real blast radius. That pushes us towards a gateway enforcement point, short-lived workload identity, policy-as-code, a signed tool registry, and audit logs. These will help you run things at enterprise scale.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=227c4c0c92f8" width="1" height="1" alt="">
